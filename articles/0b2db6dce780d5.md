---
title: "【入門】Rails エンジニアが知っておきたい配列・ハッシュ・Set の違いと使い分け"
emoji: "🍟"
type: "tech"
topics: [rails, ruby, 配列, ハッシュ, set]
published: false
publication_name: "linkedge"
---

## はじめに

皆さんは配列・ハッシュ・Set をどのように使い分けていますか？

「なんとなく使い分けている」という方も多いかと思いますが、選び方ひとつでパフォーマンスに大きく差が出ることがあります。

本記事では、基本的な違いから Rails での実践的な使い分けまでを整理しました。

少しでも皆様の参考になりますと幸いです。

![](https://storage.googleapis.com/zenn-user-upload/998e9440e305-20260226.png =100x)

## 注意点

:::message alert
- 内容に誤りが含まれている可能性があります
- コメントなどでご指摘いただけると幸いです
:::

## 環境

:::message
- Docker Desktop：4.62.0
- Docker Engine：29.2.1
- Ruby：3.3.5
- Rails：7.0.8.6
:::

## 配列（Array）

### 配列とは

配列とは、複数の値を順番に並べて管理するデータ構造です。
各要素にはインデックス（0始まり）でアクセスします。

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

fruits[0]  #=> "りんご"
fruits[1]  #=> "みかん"
fruits[2]  #=> "ぶどう"
```

https://docs.ruby-lang.org/ja/3.3/class/Array.html

### 配列の特徴

- **順序がある**：要素の並び順が保証される
- **インデックスでアクセス**：0, 1, 2, ... の数値で取得する
- **重複を許容する**：同じ値を複数格納できる
- **任意の型を混在できる**：文字列、数値、オブジェクトなどを混ぜて格納できる

```ruby
# 重複OK
numbers = [1, 2, 2, 3, 3, 3]

# 型の混在もOK
mixed = ["文字列", 100, true, nil]
```

### 配列のよく使うメソッド

#### 要素の追加

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

fruits.push("もも")  #=> ["りんご", "みかん", "ぶどう", "もも"]
fruits << "いちご"    #=> ["りんご", "みかん", "ぶどう", "もも", "いちご"]
```

#### 要素数の取得

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

fruits.length  #=> 3（配列の要素数を返す）
fruits.count   #=> 3（条件付きでも使える）

# countは条件を指定できる
numbers = [1, 2, 2, 2, 3, 3]
numbers.count(2)  #=> 3（値が2の要素数）
```

#### 繰り返し処理

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

# 各要素に対して処理を実行
fruits.each do |fruit|
  puts fruit
end

# 各要素を変換して新しい配列を作成
fruits.map { |fruit| "#{fruit}ジュース" }
#=> ["りんごジュース", "みかんジュース", "ぶどうジュース"]
```

#### 検索・絞り込み

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

fruits.include?("みかん")  #=> true

# 条件に一致する要素を抽出
fruits.select { |fruit| fruit.include?("ん") }
#=> ["りんご", "みかん"]
```

#### 並べ替え

```ruby
numbers = [3, 1, 4, 1, 5]

numbers.sort          #=> [1, 1, 3, 4, 5]
numbers.sort.reverse  #=> [5, 4, 3, 1, 1]
```

## ハッシュ（Hash）

### ハッシュとは

ハッシュとは、キーと値のペアでデータを管理するデータ構造です。
各要素にはキーでアクセスします。

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

user[:name]  #=> "佐藤"
user[:age]   #=> 25
user[:role]  #=> "エンジニア"
```

https://docs.ruby-lang.org/ja/3.3/class/Hash.html

### ハッシュの特徴

- **キーと値のペア**：名前付きでデータを管理できる
- **キーは一意**：同じキーが重複すると、後から追加した値で上書きされる
- **順序がある**：挿入順が保持される
- **任意の型をキーにできる**：シンボル、文字列、数値など

```ruby
# キーが重複すると上書き
hash = { a: 1, b: 2, a: 3 }
hash[:a]  #=> 3

# 文字列キーも使える
hash = { "name" => "佐藤", "age" => 25 }
```

### ハッシュのよく使うメソッド

#### 要素の追加・更新

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

user[:email] = "example@test.com"
user[:age] = 26
```

#### キー・値の取得

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

user.keys    #=> [:name, :age, :role]
user.values  #=> ["佐藤", 25, "エンジニア"]
```

#### 繰り返し処理

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

# 各キーと値に対して処理を実行
user.each do |key, value|
  puts "#{key}: #{value}"
end

# 値だけを変換して新しいハッシュを作成
user.transform_values { |value| value.to_s }
#=> { name: "佐藤", age: "25", role: "エンジニア" }
```

#### 検索・判定

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

user.key?(:name)          #=> true
user.value?("エンジニア")   #=> true

# 条件に一致する要素を抽出
user.select { |key, value| value.is_a?(String) }
#=> { name: "佐藤", role: "エンジニア" }
```

#### マージ

```ruby
defaults = { role: "一般", active: true }
user = { name: "佐藤", role: "エンジニア" }

# 同じキーがある場合、後のハッシュの値で上書きされる
defaults.merge(user)
#=> { role: "エンジニア", active: true, name: "佐藤" }
```

## Set（集合）

### Set とは

Set とは、重複のない要素の集合を管理するデータ構造です。
内部的にはハッシュで実装されており、検索がハッシュと同様に高速（O(1)）です。

```ruby
fruits = Set.new(["りんご", "みかん", "ぶどう"])

# 重複は自動で排除される
fruits.add("りんご")
#=> #<Set: {"りんご", "みかん", "ぶどう"}>

# 高速な検索（O(1)）
fruits.include?("みかん")  #=> true
```

https://docs.ruby-lang.org/ja/3.3/class/Set.html

### Set の特徴

- **重複を許容しない**：同じ値を追加しても自動で排除される
- **検索が高速**：内部がハッシュのため `include?` が O(1) で動作する
- **順序がある**：Ruby の実装上、挿入順が保持される
- **集合演算ができる**：積集合・和集合・差集合などが使える

### Set のよく使うメソッド

#### 要素の追加・削除

```ruby
fruits = Set.new(["りんご", "みかん"])

fruits.add("ぶどう")       #=> #<Set: {"りんご", "みかん", "ぶどう"}>
fruits.delete("みかん")    #=> #<Set: {"りんご", "ぶどう"}>
```

#### 集合演算

```ruby
a = Set.new([1, 2, 3])
b = Set.new([2, 3, 4])

a & b   #=> #<Set: {2, 3}>        （積集合：両方に含まれる要素）
a | b   #=> #<Set: {1, 2, 3, 4}>  （和集合：どちらかに含まれる要素）
a - b   #=> #<Set: {1}>           （差集合：aにだけ含まれる要素）
```

#### 部分集合の判定

```ruby
a = Set.new([1, 2])
b = Set.new([1, 2, 3, 4])

a.subset?(b)    #=> true（aはbの部分集合）
b.superset?(a)  #=> true（bはaの上位集合）
```

## 配列・ハッシュ・Set の違い早見表

| 項目 | 配列（Array） | ハッシュ（Hash） | Set（集合） |
| --- | --- | --- | --- |
| アクセス方法 | インデックス（数値） | キー（シンボル・文字列など） | 値そのもの |
| 用途 | 順序のあるデータの集合 | 名前付きデータの集合 | 重複のないデータの集合 |
| 重複 | 値の重複OK | キーの重複NG（上書き） | 値の重複NG（自動排除） |
| 検索速度（値の検索） | 要素数に比例（O(n)） | ほぼ一定（O(1)） | ほぼ一定（O(1)） |
| 適した場面 | 一覧・リスト・繰り返し処理 | 属性・設定・マッピング | 一意な値の管理・存在チェック |

## Rails での使い分け

ここからは、Rails の実務でよく見る配列・ハッシュ・Set の使い分けを具体例で紹介します。

### 配列が適しているケース

#### 1. ActiveRecordのリレーション結果を扱う

```ruby
# userの投稿一覧（順序のあるデータの集合）
posts = user.posts.order(created_at: :desc)

posts.each do |post|
  puts post.title
end
```

#### 2. セレクトボックスの選択肢

```ruby
# ビューで使う選択肢の一覧
PREFECTURES = ["北海道", "青森県", "岩手県", "宮城県", "秋田県"]

# enumの定義
class Post < ApplicationRecord
  enum :status, [:draft, :published, :archived]
end
```

#### 3. バッチ処理での一括操作

```ruby
# IDの一覧を配列で管理し、一括処理
target_ids = [1, 5, 10, 15]
Post.where(id: target_ids).update_all(published: true)
```

### ハッシュが適しているケース

#### 1. paramsの処理

```ruby
# Railsのparamsはハッシュライクなオブジェクト
def create
  @post = Post.new(post_params)
end

private

def post_params
  params.require(:post).permit(:title, :body, :status)
  # => { title: "タイトル", body: "本文", status: "published" }
end
```

#### 2. 設定値やオプションの管理

```ruby
# メール送信のオプション
mail_options = {
  to: user.email,
  subject: "お知らせ",
  template_name: "notification"
}

NotificationMailer.send_mail(mail_options).deliver_later
```

#### 3. APIレスポンスの構築

```ruby
def show
  post = Post.find(params[:id])

  render json: {
    id: post.id,
    title: post.title,
    author: {
      name: post.user.name,
      email: post.user.email
    },
    created_at: post.created_at.iso8601
  }
end
```

#### 4. 値のマッピング

```ruby
# ステータスコードと表示名の対応
STATUS_LABELS = {
  draft: "下書き",
  published: "公開中",
  archived: "アーカイブ"
}

STATUS_LABELS[:published]  #=> "公開中"
```

### Set が適しているケース

#### 1. 重複排除が必要な一覧の管理

```ruby
# タグの一覧を重複なしで管理
tags = Set.new
posts.each do |post|
  post.tags.each { |tag| tags.add(tag.name) }
end
# 同じタグ名が何度追加されても重複しない
```

#### 2. 大量データに対する存在チェック

```ruby
# 公開済み記事のIDをSetで保持し、高速に判定
published_ids = Set.new(Post.where(status: :published).pluck(:id))

posts.each do |post|
  if published_ids.include?(post.id)
    # 公開済みの処理
  end
end
```

#### 3. 権限やロールの判定

```ruby
# ユーザーの権限をSetで管理
admin_permissions = Set.new([:read, :write, :delete, :manage])
editor_permissions = Set.new([:read, :write])

# 権限の差分を確認
admin_permissions - editor_permissions
#=> #<Set: {:delete, :manage}>

# 特定の権限を持っているか判定
editor_permissions.include?(:write)  #=> true
```

## パフォーマンスの違い

配列・ハッシュ・Set では、検索のパフォーマンスに大きな差があります。

### 配列の検索：O(n)

配列で特定の要素を探す場合、先頭から順に探すため、要素数が増えるほど遅くなります。

```ruby
# 要素数が多いと遅くなる
large_array = (1..100_000).to_a

large_array.include?(99_999)  # 先頭から順に探す → 遅い
```

### ハッシュの検索：O(1)

ハッシュはキーから直接値を取得できるため、要素数に関係なくほぼ一定の速度です。

```ruby
# 要素数が多くても速い
large_hash = (1..100_000).each_with_object({}) { |i, h| h[i] = true }

large_hash[99_999]  # キーで直接アクセス → 速い
```

### Set の検索：O(1)

Set は内部的にハッシュで実装されているため、ハッシュと同様にほぼ一定の速度で検索できます。
「値が含まれるかどうか」だけを判定したい場合は、ハッシュよりも意図が明確です。

```ruby
# 要素数が多くても速い
large_set = Set.new(1..100_000)

large_set.include?(99_999)  # ハッシュで直接アクセス → 速い
```

## 迷ったときの判断基準

最後に、配列・ハッシュ・Set のどれを使うか迷ったときの判断基準をまとめます。

**配列を選ぶとき：**
- データの順序が重要
- 繰り返し処理がメインの用途
- 要素に名前が不要

**ハッシュを選ぶとき：**
- キーで直接アクセスしたい
- データに名前を付けたい
- 検索の速度を重視したい

**Set を選ぶとき：**
- 重複のない値の集合を扱いたい
- 「含まれるかどうか」の判定を高速に行いたい
- 集合演算（積集合・和集合・差集合）を使いたい

## まとめ

配列・ハッシュ・Set の違いと使い分けについてまとめてみました。

- 配列は「順番のあるデータの集まり」に適している
- ハッシュは「名前付きデータの管理」や「高速な検索」に適している
- Set は「重複のない値の集合」や「高速な存在チェック」に適している
- 検索頻度が高い場合は、配列よりもハッシュや Set を使うことでパフォーマンスが向上する

適切に配列・ハッシュ・Set を使い分けることでパフォーマンスを向上させていきましょう。

最後までお読みいただき、ありがとうございました。

---
title: "【入門】Rails エンジニアが知っておきたい配列とハッシュの違いと使い分け"
emoji: "🍟"
type: "tech"
topics: [rails, ruby, 配列, ハッシュ, パフォーマンスチューニング]
published: false
publication_name: "linkedge"
---

## はじめに

皆さんは**配列**と**ハッシュ**をどのように使い分けていますか？

「なんとなく使い分けている」という方も多いかと思いますが、選び方ひとつで可読性やパフォーマンスに大きく差が出ることがあります。

本記事では、基本的な違いから Rails での実践的な使い分けまでを整理しました。

少しでも皆様の参考になりますと幸いです。

![](https://storage.googleapis.com/zenn-user-upload/998e9440e305-20260226.png =100x)

## 注意点

:::message alert
- 内容に誤りが含まれている可能性があります
- コメントなどでご指摘いただけると幸いです
:::

## 環境

:::message
- Docker Desktop：4.62.0
- Docker Engine：29.2.1
- Ruby：3.3.5
- Rails：7.0.8.6
:::

## 配列（Array）

### 配列とは

配列とは、複数の値を順番に並べて管理するデータ構造です。
各要素にはインデックス（0始まり）でアクセスします。

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

fruits[0]  #=> "りんご"
fruits[1]  #=> "みかん"
fruits[2]  #=> "ぶどう"
```

https://docs.ruby-lang.org/ja/3.3/class/Array.html

### 配列の特徴

- **順序がある**：要素の並び順が保証される
- **インデックスでアクセス**：0, 1, 2, ... の数値で取得する
- **重複を許容する**：同じ値を複数格納できる
- **任意の型を混在できる**：文字列、数値、オブジェクトなどを混ぜて格納できる

```ruby
# 重複OK
numbers = [1, 2, 2, 3, 3, 3]

# 型の混在もOK
mixed = ["文字列", 100, true, nil]
```

### 配列のよく使うメソッド

#### 要素の追加

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

fruits.push("もも")  #=> ["りんご", "みかん", "ぶどう", "もも"]
fruits << "いちご"    #=> ["りんご", "みかん", "ぶどう", "もも", "いちご"]
```

#### 要素数の取得

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

fruits.length  #=> 3（配列の要素数を返す）
fruits.count   #=> 3（条件付きでも使える）

# countは条件を指定できる
numbers = [1, 2, 2, 3, 3, 3]
numbers.count(3)  #=> 3（値が3の要素数）
```

#### 繰り返し処理

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

# 各要素に対して処理を実行
fruits.each do |fruit|
  puts fruit
end

# 各要素を変換して新しい配列を作成
fruits.map { |fruit| "#{fruit}ジュース" }
#=> ["りんごジュース", "みかんジュース", "ぶどうジュース"]
```

#### 検索・絞り込み

```ruby
fruits = ["りんご", "みかん", "ぶどう"]

fruits.include?("みかん")  #=> true

# 条件に一致する要素を抽出
fruits.select { |fruit| fruit.include?("ん") }
#=> ["りんご", "みかん"]
```

#### 並べ替え

```ruby
numbers = [3, 1, 4, 1, 5]

numbers.sort          #=> [1, 1, 3, 4, 5]
numbers.sort.reverse  #=> [5, 4, 3, 1, 1]
```

## ハッシュ（Hash）

### ハッシュとは

ハッシュとは、キーと値のペアでデータを管理するデータ構造です。
各要素にはキーでアクセスします。

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

user[:name]  #=> "佐藤"
user[:age]   #=> 25
user[:role]  #=> "エンジニア"
```

https://docs.ruby-lang.org/ja/3.3/class/Hash.html

### ハッシュの特徴

- **キーと値のペア**：名前付きでデータを管理できる
- **キーは一意**：同じキーが重複すると、後から追加した値で上書きされる
- **順序がある**：挿入順が保持される
- **任意の型をキーにできる**：シンボル、文字列、数値など

```ruby
# キーが重複すると上書き
hash = { a: 1, b: 2, a: 3 }
hash[:a]  #=> 3

# 文字列キーも使える
hash = { "name" => "佐藤", "age" => 25 }
```

### ハッシュのよく使うメソッド

#### 要素の追加・更新

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

user[:email] = "example@test.com"
user[:age] = 26
```

#### キー・値の取得

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

user.keys    #=> [:name, :age, :role]
user.values  #=> ["佐藤", 25, "エンジニア"]
```

#### 繰り返し処理

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

# 各キーと値に対して処理を実行
user.each do |key, value|
  puts "#{key}: #{value}"
end

# 値だけを変換して新しいハッシュを作成
user.transform_values { |value| value.to_s }
#=> { name: "佐藤", age: "25", role: "エンジニア" }
```

#### 検索・判定

```ruby
user = { name: "佐藤", age: 25, role: "エンジニア" }

user.key?(:name)          #=> true
user.value?("エンジニア")   #=> true

# 条件に一致する要素を抽出
user.select { |key, value| value.is_a?(String) }
#=> { name: "佐藤", role: "エンジニア" }
```

#### マージ

```ruby
defaults = { role: "一般", active: true }
user = { name: "佐藤", role: "エンジニア" }

# 同じキーがある場合、後のハッシュの値で上書きされる
defaults.merge(user)
#=> { role: "エンジニア", active: true, name: "佐藤" }
```

## 配列とハッシュの違い早見表

| 項目 | 配列（Array） | ハッシュ（Hash） |
| --- | --- | --- |
| アクセス方法 | インデックス（数値） | キー（シンボル・文字列など） |
| 用途 | 順序のあるデータの集合 | 名前付きデータの集合 |
| 重複 | 値の重複OK | キーの重複NG（上書き） |
| 検索速度 | 要素数に比例（O(n)） | ほぼ一定（O(1)） |
| 適した場面 | 一覧・リスト・繰り返し処理 | 属性・設定・マッピング |

## Rails での使い分け

ここからは、**Rails**の実務でよく見る配列とハッシュの使い分けを具体例で紹介します。

### 配列が適しているケース

#### 1. ActiveRecordのリレーション結果を扱う

```ruby
# userの投稿一覧（順序のあるデータの集合）
posts = user.posts.order(created_at: :desc)

posts.each do |post|
  puts post.title
end
```

#### 2. セレクトボックスの選択肢

```ruby
# ビューで使う選択肢の一覧
PREFECTURES = ["北海道", "青森県", "岩手県", "宮城県", "秋田県"]

# enumの定義
class Post < ApplicationRecord
  enum status: [:draft, :published, :archived]
end
```

#### 3. バッチ処理での一括操作

```ruby
# IDの一覧を配列で管理し、一括処理
target_ids = [1, 5, 10, 15]
Post.where(id: target_ids).update_all(published: true)
```

### ハッシュが適しているケース

#### 1. paramsの処理

```ruby
# Railsのparamsはハッシュライクなオブジェクト
def create
  @post = Post.new(post_params)
end

private

def post_params
  params.require(:post).permit(:title, :body, :status)
  # => { title: "タイトル", body: "本文", status: "published" }
end
```

#### 2. 設定値やオプションの管理

```ruby
# メール送信のオプション
mail_options = {
  to: user.email,
  subject: "お知らせ",
  template_name: "notification"
}

NotificationMailer.send_mail(mail_options).deliver_later
```

#### 3. APIレスポンスの構築

```ruby
def show
  post = Post.find(params[:id])

  render json: {
    id: post.id,
    title: post.title,
    author: {
      name: post.user.name,
      email: post.user.email
    },
    created_at: post.created_at.iso8601
  }
end
```

#### 4. 値のマッピング

```ruby
# ステータスコードと表示名の対応
STATUS_LABELS = {
  draft: "下書き",
  published: "公開中",
  archived: "アーカイブ"
}

STATUS_LABELS[:published]  #=> "公開中"
```

## パフォーマンスの違い

配列とハッシュでは、**検索のパフォーマンス**に大きな差があります。

### 配列の検索：O(n)

配列で特定の要素を探す場合、先頭から順に探すため、要素数が増えるほど遅くなります。

```ruby
# 要素数が多いと遅くなる
large_array = (1..100_000).to_a

large_array.include?(99_999)  # 先頭から順に探す → 遅い
```

### ハッシュの検索：O(1)

ハッシュはキーから直接値を取得できるため、要素数に関係なくほぼ一定の速度です。

```ruby
# 要素数が多くても速い
large_hash = (1..100_000).each_with_object({}) { |i, h| h[i] = true }

large_hash[99_999]  # キーで直接アクセス → 速い
```

### 実務での活用例

特定の値が含まれているかを頻繁にチェックする場合、配列よりハッシュ（または**Set**）を使った方がパフォーマンスが向上します。

```ruby
# 非推奨：配列で毎回検索（遅い）
blocked_user_ids = BlockedUser.pluck(:user_id)  # [1, 5, 10, 15, ...]

users.each do |user|
  next if blocked_user_ids.include?(user.id)  # O(n) × ユーザー数
end

# 推奨：ハッシュ（Set）で検索（速い）
blocked_user_ids = BlockedUser.pluck(:user_id).to_set

users.each do |user|
  next if blocked_user_ids.include?(user.id)  # O(1) × ユーザー数
end
```

:::message
**Set**は、ハッシュと同様にO(1)で検索でき、重複を許容しないデータ構造です。
「値が含まれているか」だけを判定したい場合は、**Set**が最適です。
:::

## 配列とハッシュの相互変換

実務では、配列とハッシュを相互に変換する場面もよくあります。

```ruby
# 配列 → ハッシュ
pairs = [[:name, "佐藤"], [:age, 25]]
pairs.to_h  #=> { name: "佐藤", age: 25 }

# ハッシュ → 配列
user = { name: "佐藤", age: 25 }
user.to_a  #=> [[:name, "佐藤"], [:age, 25]]

# 配列からハッシュを作る（実務でよく使う）
users = User.where(active: true)
user_map = users.index_by(&:id)
# => { 1 => #<User id: 1, ...>, 5 => #<User id: 5, ...> }

# IDで直接アクセスできるようになる
user_map[5]  #=> #<User id: 5, ...>
```

:::message
**index_by**は**Rails**（**ActiveSupport**）が提供するメソッドで、配列からハッシュを簡単に作成できます。
N+1問題の回避や、ループ内での検索を高速化したい場面で重宝します。
:::

## 迷ったときの判断基準

最後に、配列とハッシュのどちらを使うか迷ったときの判断基準をまとめます。

**配列を選ぶとき：**
- データの**順序**が重要
- **繰り返し処理**がメインの用途
- 要素に**名前（ラベル）が不要**

**ハッシュを選ぶとき：**
- **キーで直接アクセス**したい
- データに**意味のある名前**を付けたい
- **検索の速度**を重視したい

## まとめ

**配列**と**ハッシュ**の違いと使い分けについてまとめてみました。

- **配列**は「順番のあるデータの集まり」に適している
- **ハッシュ**は「名前付きデータの管理」や「高速な検索」に適している
- 検索頻度が高い場合は、配列よりもハッシュや**Set**を使うことでパフォーマンスが向上する
- **Rails**では`index_by`や`to_set`を活用することで、効率的なコードが書ける

普段なんとなく使い分けていた方も、改めて整理してみると「こっちの方が適切だった」という場面が見つかるかもしれません。

最後までお読みいただき、ありがとうございました。

## 参考文献

https://docs.ruby-lang.org/ja/latest/class/Array.html

https://docs.ruby-lang.org/ja/latest/class/Hash.html

https://docs.ruby-lang.org/ja/latest/class/Set.html

https://railsguides.jp/active_support_core_extensions.html

https://pikawaka.com/ruby/array

https://pikawaka.com/ruby/hash
